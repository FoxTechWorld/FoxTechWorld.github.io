<!doctype html><html lang=pt-BR><head><title>Osdev: Até onde dá para usar c++ // FoxTechWorld</title><link rel="shortcut icon" href=images/favicon.png><link rel=apple-touch-icon sizes=180x180 href=../../../images/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../../images/favicon-32.png><link rel=icon type=image/png sizes=16x16 href=../../../images/favicon-16.png><link rel=icon type=image/png sizes=48x48 href=../../../images/favicon-48.png><link rel=icon type=image/png sizes=192x192 href=../../../images/android-chrome-192x192.png><link rel=icon type=image/png sizes=512x512 href=../../../images/android-chrome-512x512.png><meta charset=utf-8><meta name=generator content="Hugo 0.151.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="KitsuneSemCalda"><meta name=description content><link rel=stylesheet href=../../../css/main.min.113d98e5d5c20f9644b531dbb0c90cb6ccc664d280e843d1ba8a8c5abf0171b2.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-5Z4YGJXDLT"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5Z4YGJXDLT")}</script><meta name=twitter:card content="summary"><meta name=twitter:title content="Osdev: Até onde dá para usar c++"><meta name=twitter:description content="Estou desenvolvendo um kernel chamado FKernel.
Para uso desktop em código x86_64.
E lendo sobre algumas linguagens como Rust, C, C++, Zig …
Decidi fazer uma combinação de:
Linguagens de Programação: C C++ Linguagem de montagem: Nasm Obviamente alguns podem estranhar já que eu propositalmente ignorei Rust, e aquelas que são considerados “memory-safe”.
Porque não usar linguagens memory-safe? Pro Tip: Não existe linguagem memory-safe em baixo nível. Para programar um kernel ou similar, você vai depender do unsafe então nem tenta."><meta property="og:url" content="https://foxtechword.github.io/2025/09/osdev-at%C3%A9-onde-d%C3%A1-para-usar-c/"><meta property="og:site_name" content="FoxTechWorld"><meta property="og:title" content="Osdev: Até onde dá para usar c++"><meta property="og:description" content="Estou desenvolvendo um kernel chamado FKernel.
Para uso desktop em código x86_64.
E lendo sobre algumas linguagens como Rust, C, C++, Zig …
Decidi fazer uma combinação de:
Linguagens de Programação: C C++ Linguagem de montagem: Nasm Obviamente alguns podem estranhar já que eu propositalmente ignorei Rust, e aquelas que são considerados “memory-safe”.
Porque não usar linguagens memory-safe? Pro Tip: Não existe linguagem memory-safe em baixo nível. Para programar um kernel ou similar, você vai depender do unsafe então nem tenta."><meta property="og:locale" content="pt_BR"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-22T15:33:40-03:00"><meta property="article:modified_time" content="2025-09-22T15:33:40-03:00"><meta property="article:tag" content="Osdev"><meta property="article:tag" content="C++"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="Kernel"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Windows"></head><body><header class=app-header><a href=../../../><img class=app-header-avatar src=../../../images/avatar.png alt=KitsuneSemCalda></a>
<span class=app-header-title>FoxTechWorld</span><nav class=app-header-menu><a class=app-header-menu-item href=../../../>Home</a>
-
<a class=app-header-menu-item href=../../../posts/>Posts</a>
-
<a class=app-header-menu-item href=../../../tags/>Tags</a>
-
<a class=app-header-menu-item href=../../../rss.xml>Rss</a></nav><p>Tentando tornar o mundo menos pop e mais nérdico</p><div class=app-header-social><a href=https://github.com/KitsuneSemCalda target=_blank rel="noreferrer noopener me"><svg class="icon icon-brand-github" viewBox="0 0 24 24" fill="currentColor"><title>GitHub</title><path d="M12 .3C5.4.3.0 5.7.0 12 0 18 3.4 22 8.2 24 8.8 24 9 23 9 23 9 23 9 22 9 21 5.7 22 5 19 5 19 4.4 18 3.6 18 3.6 18 2.5 17 3.7 17 3.7 17 4.9 17 5.6 18 5.6 18 6.6 20 8.4 20 9.1 19 9.2 18 9.5 18 9.8 18 7.1 17 4.3 16 4.3 12c0-1.3.47-2.4 1.2-3.2-.14-.3-.54-1.5.11-3.2.0.0 1-.32 3.3 1.2.96-.27 2-.4 3-.41 1 .006 2 .14 3 .41C17 5 18 5.3 18 5.3 19 6.9 19 8.1 18 8.5 19 9.3 20 10 20 12 20 16 17 17 14 18 15 18 15 19 15 20 15 21 15 23 15 23c0 .32.21.69.83.57C21 22 24 18 24 12c0-6.6-5.4-12-12-12"/></svg>
</a><a href=https://twitter.com/@KitsuneSemCalda target=_blank rel="noreferrer noopener me"><svg class="icon icon-brand-x" viewBox="0 0 24 24" fill="currentColor"><title>X</title><path d="M19 1.2H23L15 10 24 23H17L11 15 4.2 23H.47L9.1 13 0 1.2h7.6L13 8.1zM18 21h2l-13-17H4.3z"/></svg>
</a><a href=https://discord.gg/WTMr49Nfp5 target=_blank rel="noreferrer noopener me"><svg class="icon icon-brand-discord" viewBox="0 0 24 24" fill="currentColor"><title>Discord</title><path d="M20 4.4A20 20 0 0015 2.9.074.074.0 0015 2.9C15 3.3 15 3.8 15 4.1 13 3.9 11 3.9 9.3 4.1 9.1 3.7 8.9 3.3 8.6 2.9A.077.077.0 008.6 2.9 20 20 0 003.7 4.4.07.07.0 003.6 4.4C.53 9-.32 14 .099 18A.082.082.0 00.13 18c2.1 1.5 4 2.4 6 3A.078.078.0 006.2 21c.46-.63.87-1.3 1.2-2A.076.076.0 007.4 19C6.7 19 6.1 18 5.5 18A.077.077.0 015.5 18C5.6 18 5.8 18 5.9 18A.074.074.0 016 18C9.9 19 14 19 18 18A.074.074.0 0118 18C18 18 18 18 18 18A.077.077.0 0118 18 12 12 0 0117 19 .077.077.0 0017 19C17 20 17 20 18 21A.076.076.0 0018 21c2-.61 3.9-1.5 6-3A.077.077.0 0024 18C24 13 23 8.4 20 4.4A.061.061.0 0020 4.4zM8 15C6.8 15 5.9 14 5.9 13 5.9 12 6.8 10 8 10 9.2 10 10 12 10 13 10 14 9.2 15 8 15zm8 0C15 15 14 14 14 13 14 12 15 10 16 10 17 10 18 12 18 13 18 14 17 15 16 15z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Osdev: Até onde dá para usar c++</h1><div class=post-meta><div><svg class="icon icon-calendar" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
Sep 22, 2025</div><div><svg class="icon icon-clock" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
5 min read</div><div><svg class="icon icon-tag" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>tag</title><path d="M21 13 13 21A2 2 0 0111 21L2 12V2h10L21 11a2 2 0 010 2.8z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<a class=tag href=../../../tags/osdev/>Osdev</a>
<a class=tag href=../../../tags/c++/>C++</a>
<a class=tag href=../../../tags/cpp/>Cpp</a>
<a class=tag href=../../../tags/kernel/>Kernel</a>
<a class=tag href=../../../tags/linux/>Linux</a>
<a class=tag href=../../../tags/windows/>Windows</a>
<a class=tag href=../../../tags/macosx/>Macosx</a></div></div><nav id=TableOfContents><ul><li><ul><li><a href=#porque-não-usar-linguagens-memory-safe>Porque não usar linguagens memory-safe?</a></li><li><a href=#e-porque-c>E porque C++?</a><ul><li><a href=#implementação-do-iokit>Implementação do IOKit</a></li><li><a href=#realmente-preciso-do-stl>Realmente preciso do STL?</a></li></ul></li><li><a href=#e-no-fim>E no fim?</a></li></ul></li></ul></nav></header><div class=post-content><p>Estou desenvolvendo um <a href=https://pt.wikipedia.org/wiki/N%C3%BAcleo_(sistema_operacional)>kernel</a> chamado FKernel.</p><p>Para uso desktop em código x86_64.</p><p>E lendo sobre algumas linguagens como <strong><em>Rust</em></strong>, <strong><em>C</em></strong>, <strong><em>C++</em></strong>, <strong><em>Zig</em></strong> &mldr;</p><p>Decidi fazer uma combinação de:</p><ul><li>Linguagens de Programação:<ul><li>C</li><li>C++</li></ul></li><li>Linguagem de montagem:<ul><li>Nasm</li></ul></li></ul><p>Obviamente alguns podem estranhar já que eu propositalmente ignorei Rust, e aquelas que são considerados &ldquo;memory-safe&rdquo;.</p><h2 id=porque-não-usar-linguagens-memory-safe>Porque não usar linguagens memory-safe?</h2><p>Pro Tip: Não existe linguagem memory-safe em baixo nível. Para programar um kernel ou similar, você vai depender do unsafe então nem tenta.</p><p>Se for para ter que lidar com sintaxes estranhas para programar um kernel, eu prefiro seguir no bom e velho C/C++.</p><p>Também não quero fazer um overflow de logs de um compilador super-nanny para chegar a um subset daquilo que eu queria no meu código.</p><h2 id=e-porque-c>E porque C++?</h2><p>Muito tempo atrás Linus Torvalds havia tentado escrever um kernel com a versão de sua época.</p><blockquote><p>C++ leads to really, really bad design choices. You invariably start using the STL, boost, and other total and utter crap…</p></blockquote><p>Ok, podemos concordar em algumas partes mas, isso não seria inevitavelmente ruim.</p><p>Sim, C++ tem um monte de coisa, mas fugiria do ponto principal que é C++ dá contratos que structs sozinhas dificilmente conseguem.</p><p>Pegue um exemplo do <code>SerenityOS</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>static</span> ErrorOr<span style=color:#f92672>&lt;</span>NonnullOwnPtr<span style=color:#f92672>&lt;</span>KBuffer<span style=color:#f92672>&gt;&gt;</span> try_create_with_size(StringView name,
</span></span><span style=display:flex><span>size_t size,
</span></span><span style=display:flex><span>Memory<span style=color:#f92672>::</span>Region<span style=color:#f92672>::</span>Access access <span style=color:#f92672>=</span> Memory<span style=color:#f92672>::</span>Region<span style=color:#f92672>::</span>Access<span style=color:#f92672>::</span>ReadWrite,
</span></span><span style=display:flex><span>AllocationStrategy strategy <span style=color:#f92672>=</span> AllocationStrategy<span style=color:#f92672>::</span>Reserve){
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>auto</span> rounded_size <span style=color:#f92672>=</span> TRY(Memory<span style=color:#f92672>::</span>page_round_up(size));
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>auto</span> region <span style=color:#f92672>=</span> TRY(MM.allocate_kernel_region(rounded_size, name, access, strategy));
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>TRY</span>(adopt_nonnull_own_or_enomem(<span style=color:#66d9ef>new</span> (nothrow) KBuffer { size, move(region) }));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Consegue entender o que esse código faz? Todo esse contrato engloba em poucas linhas</p><blockquote><p>Essa função try_create_with_size serve para criar um buffer de memória no kernel de um tamanho específico e lidar com possíveis erros de forma segura.</p></blockquote><p>Para termos o equivalente exato em C garantindo a mesma segurança seria necessária escrever dessa forma.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>try_create_with_size</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> name,
</span></span><span style=display:flex><span>                         <span style=color:#66d9ef>size_t</span> size,
</span></span><span style=display:flex><span>                         MemoryAccess access,
</span></span><span style=display:flex><span>                         AllocationStrategy strategy,
</span></span><span style=display:flex><span>                         KBuffer<span style=color:#f92672>**</span> out_buffer) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>out_buffer) <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> rounded_size;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> rc <span style=color:#f92672>=</span> <span style=color:#a6e22e>page_round_up</span>(size, <span style=color:#f92672>&amp;</span>rounded_size);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (rc <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> rc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    MemoryRegion<span style=color:#f92672>*</span> region;
</span></span><span style=display:flex><span>    rc <span style=color:#f92672>=</span> <span style=color:#a6e22e>allocate_kernel_region</span>(rounded_size, name, access, strategy, <span style=color:#f92672>&amp;</span>region);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (rc <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> rc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    KBuffer<span style=color:#f92672>*</span> buffer <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(KBuffer));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>buffer) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>free</span>(region<span style=color:#f92672>-&gt;</span>addr);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>free</span>(region);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span>ENOMEM;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    buffer<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>=</span> size;
</span></span><span style=display:flex><span>    buffer<span style=color:#f92672>-&gt;</span>region <span style=color:#f92672>=</span> region;
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>out_buffer <span style=color:#f92672>=</span> buffer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// sucesso
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Ok, tivemos uma disparidade no tamanho, mas isso não significa nada no geral.</p><p>Meu ponto defendido é que precisamos fazer muito mais código, que vai ser muito mais performático mas que vai resultar em um resultado muito menos seguro, e muito menos reusável no geral.</p><p>Não ironicamente, muitos empresas incluindo a própria Apple usam o C++ em seus kernels.</p><p>Mas não precisa ser o c++ inteiro e sim um subset chamado <a href=https://en.wikipedia.org/wiki/Embedded_C%2B%2B><strong><em>embedded c++</em></strong></a>.</p><h3 id=implementação-do-iokit>Implementação do IOKit</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * This file contains Original Code and/or Modifications of Original Code
</span></span></span><span style=display:flex><span><span style=color:#75715e> * as defined in and that are subject to the Apple Public Source License
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Version 2.0 (the &#39;License&#39;). You may not use this file except in
</span></span></span><span style=display:flex><span><span style=color:#75715e> * compliance with the License. The rights granted to you under the License
</span></span></span><span style=display:flex><span><span style=color:#75715e> * may not be used to create, or enable the creation or redistribution of,
</span></span></span><span style=display:flex><span><span style=color:#75715e> * unlawful or unlicensed copies of an Apple operating system, or to
</span></span></span><span style=display:flex><span><span style=color:#75715e> * circumvent, violate, or enable the circumvention or violation of, any
</span></span></span><span style=display:flex><span><span style=color:#75715e> * terms of an Apple operating system software license agreement.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Please obtain a copy of the License at
</span></span></span><span style=display:flex><span><span style=color:#75715e> * http://www.opensource.apple.com/apsl/ and read it before using this file.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The Original Code and all software distributed under the License are
</span></span></span><span style=display:flex><span><span style=color:#75715e> * distributed on an &#39;AS IS&#39; basis, WITHOUT WARRANTY OF ANY KIND, EITHER
</span></span></span><span style=display:flex><span><span style=color:#75715e> * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
</span></span></span><span style=display:flex><span><span style=color:#75715e> * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
</span></span></span><span style=display:flex><span><span style=color:#75715e> * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Please see the License for the specific language governing rights and
</span></span></span><span style=display:flex><span><span style=color:#75715e> * limitations under the License.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifndef _IOKIT_IONVRAMCONTROLLER_H
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define _IOKIT_IONVRAMCONTROLLER_H
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;IOKit/IOService.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>IONVRAMController</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> IOService
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	OSDeclareAbstractStructors(IONVRAMController);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> registerService(IOOptionBits options <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>) APPLE_KEXT_OVERRIDE;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sync</span>(<span style=color:#66d9ef>void</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>virtual</span> IOReturn <span style=color:#a6e22e>select</span>(<span style=color:#66d9ef>uint32_t</span> bank);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>virtual</span> IOReturn <span style=color:#a6e22e>eraseBank</span>(<span style=color:#66d9ef>void</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>virtual</span> IOReturn <span style=color:#a6e22e>read</span>(IOByteCount offset, UInt8 <span style=color:#f92672>*</span>buffer,
</span></span><span style=display:flex><span>	    IOByteCount length) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>virtual</span> IOReturn <span style=color:#a6e22e>write</span>(IOByteCount offset, UInt8 <span style=color:#f92672>*</span>buffer,
</span></span><span style=display:flex><span>	    IOByteCount length) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif </span><span style=color:#75715e>/* !_IOKIT_IONVRAMCONTROLLER_H */</span><span style=color:#75715e>
</span></span></span></code></pre></div><p>Quem diria.</p><p>Se fossemos falar do C++ antes da versão 17, eu até concordaria mas após a versão 17 muita coisa mudou.</p><p>E veja que o IOKit é implementado na forma Embedded C++.</p><p>Mas, e como em tudo há um mas, há em real,o ponto da STL que invariavelmente você vai acabar usando ou não.</p><h3 id=realmente-preciso-do-stl>Realmente preciso do STL?</h3><p>No fringir dos ovos há um outro superset de C++ chamado <a href=https://terminalroot.com.br/2023/07/conheca-o-cpp-ortodoxo.html><strong><em>c++ ortodoxo</em></strong></a> jamais o use, sério.</p><p>Uma das soluções que o FKernel e o SerenityOS fazem é criar sua própria STL.</p><p>O SerenityOS com sua <strong>Abstraction Kit</strong>.
E o FKernel com seu <strong>LibFK</strong>.</p><p>Usar uma STL não é de todo mal, há diversos efeitos, como otimização em cascata.</p><p>Genericos e todo resto.</p><h2 id=e-no-fim>E no fim?</h2><p>No fim, depende de você.</p><p>Se você está desenvolvendo um app para desktop.</p><p>Eu sugeriria:</p><ul><li><a href=https://pt.wikipedia.org/wiki/D_(linguagem_de_programa%C3%A7%C3%A3o)>D</a></li><li><a href=https://pt.wikipedia.org/wiki/Go_(linguagem_de_programa%C3%A7%C3%A3o)>Go</a></li><li><a href=https://pt.wikipedia.org/wiki/Zig_(linguagem_de_programa%C3%A7%C3%A3o)>Zig</a></li><li><a href=https://pt.wikipedia.org/wiki/Rust_(linguagem_de_programa%C3%A7%C3%A3o)>Rust</a></li></ul><p>Para baixo nível certamente eu sugeriria:</p><ul><li><a href=https://pt.wikipedia.org/wiki/B_(linguagem_de_programa%C3%A7%C3%A3o)>B</a></li><li><a href=https://pt.wikipedia.org/wiki/C_(linguagem_de_programa%C3%A7%C3%A3o)>C</a>,</li><li><a href=https://pt.wikipedia.org/wiki/C%2B%2B>C++</a></li><li><a href=https://pt.wikipedia.org/wiki/D_(linguagem_de_programa%C3%A7%C3%A3o)>D</a></li><li><a href=https://pt.wikipedia.org/wiki/Rust_(linguagem_de_programa%C3%A7%C3%A3o)>Rust</a></li><li><a href=https://pt.wikipedia.org/wiki/Zig_(linguagem_de_programa%C3%A7%C3%A3o)>Zig</a></li></ul><p>Mas em kernel estou muito mais satisfeito com minha escolha do que usar C puro.</p><p>Não que eu não use C obviamente, por baixo dos panos da LibFK eu implementei uma LibC bem simples com funções que eu teria que usar dentro do FKernel para algumas funções da LibFK.</p><p>Mas enfim, se uma linguagem que você prefere usar por algum motivo de design ou simplesmente por ser a que você sabe, simplesmente use.</p><p>Desde que não seja usar algo interpretado para fazer baixo nível, tá valendo tudo.</p></div><div class=post-footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//foxtechworld-1.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></article></main></body></html>