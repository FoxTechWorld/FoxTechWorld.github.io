<!doctype html><html lang=pt-BR><head><title>Algoritmos: Duff device for loop unrolling // FoxTechWorld</title><link rel="shortcut icon" href=images/favicon.png><link rel=apple-touch-icon sizes=180x180 href=https://foxtechworld.github.io/images/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://foxtechworld.github.io/images/favicon-32.png><link rel=icon type=image/png sizes=16x16 href=https://foxtechworld.github.io/images/favicon-16.png><link rel=icon type=image/png sizes=48x48 href=https://foxtechworld.github.io/images/favicon-48.png><link rel=icon type=image/png sizes=192x192 href=https://foxtechworld.github.io/images/android-chrome-192x192.png><link rel=icon type=image/png sizes=512x512 href=https://foxtechworld.github.io/images/android-chrome-512x512.png><meta charset=utf-8><meta name=generator content="Hugo 0.155.2"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="KitsuneSemCalda"><meta name=description content="Como os compiladores conseguem otimizar loops?
A princípio isso não parece possível. Se um loop executa uma ação N vezes, o tempo total deveria ser basicamente o custo dessa ação multiplicado por N. Só que na prática, quando compilamos com -O3, o resultado é bem diferente: o mesmo loop roda mais rápido, mesmo fazendo o mesmo trabalho.
E a culpa (ou o mérito) é de um pequeno trecho de código que se tornou quase uma lenda na história da otimização em C:"><link rel=stylesheet href=https://foxtechworld.github.io/css/main.min.89e5f67d115df5e3aa766f49679ae017557cc19a8d2a174f4f5760f05edf0229.css><link rel=canonical href=https://foxtechworld.github.io/algoritmos-duff-device-for-loop-unrolling/><script async src="https://www.googletagmanager.com/gtag/js?id=G-5Z4YGJXDLT"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5Z4YGJXDLT")}</script><meta name=twitter:card content="summary"><meta name=twitter:title content="Algoritmos: Duff device for loop unrolling"><meta name=twitter:description content="Como os compiladores conseguem otimizar loops? A princípio isso não parece possível. Se um loop executa uma ação N vezes, o tempo total deveria ser basicamente o custo dessa ação multiplicado por N. Só que na prática, quando compilamos com -O3, o resultado é bem diferente: o mesmo loop roda mais rápido, mesmo fazendo o mesmo trabalho.
E a culpa (ou o mérito) é de um pequeno trecho de código que se tornou quase uma lenda na história da otimização em C:"><meta property="og:url" content="https://foxtechworld.github.io/algoritmos-duff-device-for-loop-unrolling/"><meta property="og:site_name" content="FoxTechWorld"><meta property="og:title" content="Algoritmos: Duff device for loop unrolling"><meta property="og:description" content="Como os compiladores conseguem otimizar loops? A princípio isso não parece possível. Se um loop executa uma ação N vezes, o tempo total deveria ser basicamente o custo dessa ação multiplicado por N. Só que na prática, quando compilamos com -O3, o resultado é bem diferente: o mesmo loop roda mais rápido, mesmo fazendo o mesmo trabalho.
E a culpa (ou o mérito) é de um pequeno trecho de código que se tornou quase uma lenda na história da otimização em C:"><meta property="og:locale" content="pt_BR"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-26T18:20:07-03:00"><meta property="article:modified_time" content="2025-10-26T18:20:07-03:00"><meta property="article:tag" content="Algoritmos"><meta property="article:tag" content="Estrutura De Dados"><meta property="article:tag" content="Otimização"><meta property="article:tag" content="Duff Device"><meta property="article:tag" content="Loop Unroll"><meta name=google-site-verification content="XXEJNvdhFFbUcmcEG1i9z2AaaEEKwZqE_qsFGO3ymWw"></head><body><header class=app-header><a href=https://foxtechworld.github.io/><img class=app-header-avatar src=https://foxtechworld.github.io/images/avatar.png alt=KitsuneSemCalda></a>
<span class=app-header-title>FoxTechWorld</span><nav class=app-header-menu><a class=app-header-menu-item href=https://foxtechworld.github.io/>Home</a>
-
<a class=app-header-menu-item href=https://foxtechworld.github.io/posts/>Posts</a>
-
<a class=app-header-menu-item href=https://foxtechworld.github.io/tags/>Tags</a>
-
<a class=app-header-menu-item href=https://foxtechworld.github.io/rss.xml>Rss</a></nav><p>Tentando tornar o mundo menos pop e mais nérdico</p><div class=app-header-social><a href=https://github.com/KitsuneSemCalda target=_blank rel="noreferrer noopener me"><svg class="icon icon-brand-github" viewBox="0 0 24 24" fill="currentColor"><title>GitHub</title><path d="M12 .3C5.4.3.0 5.7.0 12 0 18 3.4 22 8.2 24 8.8 24 9 23 9 23 9 23 9 22 9 21 5.7 22 5 19 5 19 4.4 18 3.6 18 3.6 18 2.5 17 3.7 17 3.7 17 4.9 17 5.6 18 5.6 18 6.6 20 8.4 20 9.1 19 9.2 18 9.5 18 9.8 18 7.1 17 4.3 16 4.3 12c0-1.3.47-2.4 1.2-3.2-.14-.3-.54-1.5.11-3.2.0.0 1-.32 3.3 1.2.96-.27 2-.4 3-.41 1 .006 2 .14 3 .41C17 5 18 5.3 18 5.3 19 6.9 19 8.1 18 8.5 19 9.3 20 10 20 12 20 16 17 17 14 18 15 18 15 19 15 20 15 21 15 23 15 23c0 .32.21.69.83.57C21 22 24 18 24 12c0-6.6-5.4-12-12-12"/></svg>
</a><a href=https://twitter.com/@KitsuneSemCalda target=_blank rel="noreferrer noopener me"><svg class="icon icon-brand-x" viewBox="0 0 24 24" fill="currentColor"><title>X</title><path d="M19 1.2H23L15 10 24 23H17L11 15 4.2 23H.47L9.1 13 0 1.2h7.6L13 8.1zM18 21h2l-13-17H4.3z"/></svg>
</a><a href=https://discord.gg/WTMr49Nfp5 target=_blank rel="noreferrer noopener me"><svg class="icon icon-brand-discord" viewBox="0 0 24 24" fill="currentColor"><title>Discord</title><path d="M20 4.4A20 20 0 0015 2.9.074.074.0 0015 2.9C15 3.3 15 3.8 15 4.1 13 3.9 11 3.9 9.3 4.1 9.1 3.7 8.9 3.3 8.6 2.9A.077.077.0 008.6 2.9 20 20 0 003.7 4.4.07.07.0 003.6 4.4C.53 9-.32 14 .099 18A.082.082.0 00.13 18c2.1 1.5 4 2.4 6 3A.078.078.0 006.2 21c.46-.63.87-1.3 1.2-2A.076.076.0 007.4 19C6.7 19 6.1 18 5.5 18A.077.077.0 015.5 18C5.6 18 5.8 18 5.9 18A.074.074.0 016 18C9.9 19 14 19 18 18A.074.074.0 0118 18C18 18 18 18 18 18A.077.077.0 0118 18 12 12 0 0117 19 .077.077.0 0017 19C17 20 17 20 18 21A.076.076.0 0018 21c2-.61 3.9-1.5 6-3A.077.077.0 0024 18C24 13 23 8.4 20 4.4A.061.061.0 0020 4.4zM8 15C6.8 15 5.9 14 5.9 13 5.9 12 6.8 10 8 10 9.2 10 10 12 10 13 10 14 9.2 15 8 15zm8 0C15 15 14 14 14 13 14 12 15 10 16 10 17 10 18 12 18 13 18 14 17 15 16 15z"/></svg>
</a><a href=https://youtube.com/@FoxTechWorld target=_blank rel="noreferrer noopener me"><svg class="icon icon-brand-youtube" viewBox="0 0 24 24" fill="currentColor"><title>YouTube</title><path d="M23 6.2A3 3 0 0021 4.1C20 3.5 12 3.5 12 3.5s-7.5.0-9.4.51A3 3 0 00.5 6.2C0 8.1.0 12 0 12S0 16 .5 18A3 3 0 002.6 20C4.5 20 12 20 12 20S20 20 21 20A3 3 0 0023 18C24 16 24 12 24 12s0-3.9-.5-5.8zM9.5 16V8.4L16 12 9.5 16z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Algoritmos: Duff device for loop unrolling</h1><div class=post-meta><div><svg class="icon icon-calendar" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
Oct 26, 2025</div><div><svg class="icon icon-clock" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
3 min read</div><div><svg class="icon icon-tag" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>tag</title><path d="M21 13 13 21A2 2 0 0111 21L2 12V2h10L21 11a2 2 0 010 2.8z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<a class=tag href=https://foxtechworld.github.io/tags/algoritmos/>Algoritmos</a>
<a class=tag href=https://foxtechworld.github.io/tags/estrutura-de-dados/>Estrutura De Dados</a>
<a class=tag href=https://foxtechworld.github.io/tags/otimiza%C3%A7%C3%A3o/>Otimização</a>
<a class=tag href=https://foxtechworld.github.io/tags/duff-device/>Duff Device</a>
<a class=tag href=https://foxtechworld.github.io/tags/loop-unroll/>Loop Unroll</a></div></div><nav id=TableOfContents><ul><li><a href=#como-os-compiladores-conseguem-otimizar-loops>Como os compiladores conseguem otimizar loops?</a><ul><li><a href=#o-que-é-o-desenrolamento-de-loops>O que é o desenrolamento de loops?</a></li><li><a href=#e-porque-isso-funciona-em-c>E porque isso funciona em C?</a></li></ul></li><li><a href=#conclusão>Conclusão</a></li></ul></nav></header><div class=post-content><h1 id=como-os-compiladores-conseguem-otimizar-loops>Como os compiladores conseguem otimizar loops?</h1><p>A princípio isso não parece possível. Se um loop executa uma ação N vezes, o tempo total deveria ser basicamente o custo dessa ação multiplicado por N. Só que na prática, quando compilamos com -O3, o resultado é bem diferente: o mesmo loop roda mais rápido, mesmo fazendo o mesmo trabalho.</p><p>E a culpa (ou o mérito) é de um pequeno trecho de código que se tornou quase uma lenda na história da otimização em C:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>register</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>to, <span style=color:#f92672>*</span>from;
</span></span><span style=display:flex><span><span style=color:#66d9ef>register</span> <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> (n <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>switch</span> (n <span style=color:#f92672>%</span> <span style=color:#ae81ff>8</span>) {
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>do</span> { <span style=color:#f92672>*</span>to <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>from<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#ae81ff>7</span><span style=color:#f92672>:</span>      <span style=color:#f92672>*</span>to <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>from<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#ae81ff>6</span><span style=color:#f92672>:</span>      <span style=color:#f92672>*</span>to <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>from<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#ae81ff>5</span><span style=color:#f92672>:</span>      <span style=color:#f92672>*</span>to <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>from<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#ae81ff>4</span><span style=color:#f92672>:</span>      <span style=color:#f92672>*</span>to <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>from<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>:</span>      <span style=color:#f92672>*</span>to <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>from<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span>      <span style=color:#f92672>*</span>to <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>from<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>case</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>      <span style=color:#f92672>*</span>to <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>from<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>while</span> (<span style=color:#f92672>--</span>count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Este pequeno frame é o <a href=https://www.gnu.org/software/c-intro-and-ref/manual/html_node/Duffs-Device.html><strong><em>Duff Device</em></strong></a> criado por <a href=https://en.wikipedia.org/wiki/Tom_Duff><strong>Tom Duff</strong></a> em 1983.</p><h2 id=o-que-é-o-desenrolamento-de-loops>O que é o desenrolamento de loops?</h2><p>Loop Unrolling (ou desenrolamento de loop) é uma técnica de otimização onde o compilador duplica o corpo do loop várias vezes para reduzir o custo do controle de iteração.</p><p>Em vez de checar a condição e incrementar o contador a cada passo, ele faz operações por iterações, diminuindo o número total de saltos no código.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i){
</span></span><span style=display:flex><span>    copia[i] <span style=color:#f92672>=</span> origem[i];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>se transforma em algo conceitualmente similar:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>4</span>) {
</span></span><span style=display:flex><span>    copia[i] <span style=color:#f92672>=</span> origem[i];
</span></span><span style=display:flex><span>    copia[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> origem[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    copia[i<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> origem[i<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>    copia[i<span style=color:#f92672>+</span><span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> origem[i<span style=color:#f92672>+</span><span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Menos branches, mais instruções seguidas, mais chance de o processador aproveitar o pipeline e executar tudo de forma quase branchless, parecido com o que o <code>SIMD</code> faz.</p><p>O Duff Device foi a primeira vez que alguém usou essa ideia manualmente, antes de os compiladores modernos fazerem isso sozinhos.</p><p>É uma daquelas otimizações que parecem mágica até você perceber que o compilador só está tentando evitar o que humanos mais odeiam: repetições desnecessárias.</p><h2 id=e-porque-isso-funciona-em-c>E porque isso funciona em C?</h2><p>A lógica do Duff Device não é muito diferente de acessar vários elementos de um array de uma vez. Se copia e origem têm o mesmo tamanho, você consegue fazer a mesma operação em uma única iteração, processando múltiplas posições do vetor ao mesmo tempo. Isso reduz o overhead de controle do loop e deixa o processador mais livre para executar instruções em sequência, aumentando a eficiência geral.</p><p>O <code>do-while</code> sozinho é simples, executa a iteração uma vez e faz o teste da condição garantindo pelo menos uma execução.</p><p>O <code>switch</code> é um salto condicional que usa <a href=https://en.wikipedia.org/wiki/Branch_table>jump-table</a> para ter tempo de execução O(1).</p><p>Agora, dentro de truque do <strong>Duff-Device</strong>: ele <strong>remove os breaks de propósito</strong> e coloca o <code>switch</code> <strong>dentro do do-while</strong>.</p><p>Isso cria efeitos simultâneos:</p><ol><li>O <code>switch</code> escolhe em qual ponto do loop começar</li><li>O <code>do-while</code> continua repetindo o bloco inteiro várias vezes até completar todas as iterações.</li></ol><p>Na prática, isso significa que você começa no case certo (alinhando as iterações que sobraram) e depois &ldquo;cai&rdquo; pelos demais cases sem saltos adicionais, repetindo tudo até terminar.</p><p>Cada execução <code>do-while</code> processa vários elementos do array, e o switch inicial só garante que você comece na posição correta.</p><h1 id=conclusão>Conclusão</h1><p>Pode ser uma técnica útil em alguns casos, mas não na maioria.</p><p>É feio, parece gambiarra e seu compilador quando passa as flags <code>-O3</code> ou <code>-funroll-loops</code> já adiciona os Duff-Devices automaticamente.</p><p>Porém se você estiver estudando programação ou pelo menos otimização de código fonte, complexidade de algoritmos vale a pena dar uama revisada.</p></div><div class=post-footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//foxtechworld-1.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></article></main></body></html>